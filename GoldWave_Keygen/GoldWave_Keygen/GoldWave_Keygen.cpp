// GoldWave_Keygen.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include <corecrt_malloc.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

char a_76_5[] = {
	0x3F, 0x37, 0x2F, 0x27, 0x1F, 0x17, 0x0F, 0x07, 0x3E, 0x36, 0x2E, 0x26, 0x1E, 0x16, 0x0E, 0x06,
	0x3D, 0x35, 0x2D, 0x25, 0x1D, 0x15, 0x0D, 0x05, 0x1C, 0x14, 0x0C, 0x04, 0x01, 0x01, 0x02, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x01, 0x0E, 0x11, 0x0B, 0x18,
	0x01, 0x05, 0x03, 0x1C, 0x0F, 0x06, 0x15, 0x0A, 0x17, 0x13, 0x0C, 0x04, 0x1A, 0x08, 0x10, 0x07,
	0x1B, 0x14, 0x0D, 0x02, 0x29, 0x34, 0x1F, 0x25, 0x2F, 0x37, 0x1E, 0x28, 0x33, 0x2D, 0x21, 0x30,
	0x2C, 0x31, 0x27, 0x38, 0x22, 0x35, 0x2E, 0x2A, 0x32, 0x24, 0x1D, 0x20, 0x20, 0x01, 0x02, 0x03,
	0x04, 0x05, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0C, 0x0D,
	0x0E, 0x0F, 0x10, 0x11, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
	0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x01, 0x0E, 0x04, 0x0D, 0x01,
	0x02, 0x0F, 0x0B, 0x08, 0x03, 0x0A, 0x06, 0x0C, 0x05, 0x09, 0x00, 0x07, 0x00, 0x0F, 0x07, 0x04,
	0x0E, 0x02, 0x0D, 0x01, 0x0A, 0x06, 0x0C, 0x0B, 0x09, 0x05, 0x03, 0x08, 0x04, 0x01, 0x0E, 0x08,
	0x0D, 0x06, 0x02, 0x0B, 0x0F, 0x0C, 0x09, 0x07, 0x03, 0x0A, 0x05, 0x00, 0x0F, 0x0C, 0x08, 0x02,
	0x04, 0x09, 0x01, 0x07, 0x05, 0x0B, 0x03, 0x0E, 0x0A, 0x00, 0x06, 0x0D, 0x0F, 0x01, 0x08, 0x0E,
	0x06, 0x0B, 0x03, 0x04, 0x09, 0x07, 0x02, 0x0D, 0x0C, 0x00, 0x05, 0x0A, 0x03, 0x0D, 0x04, 0x07,
	0x0F, 0x02, 0x08, 0x0E, 0x0C, 0x00, 0x01, 0x0A, 0x06, 0x09, 0x0B, 0x05, 0x00, 0x0E, 0x07, 0x0B,
	0x0A, 0x04, 0x0D, 0x01, 0x05, 0x08, 0x0C, 0x06, 0x09, 0x03, 0x02, 0x0F, 0x0D, 0x08, 0x0A, 0x01,
	0x03, 0x0F, 0x04, 0x02, 0x0B, 0x06, 0x07, 0x0C, 0x00, 0x05, 0x0E, 0x09, 0x0A, 0x00, 0x09, 0x0E,
	0x06, 0x03, 0x0F, 0x05, 0x01, 0x0D, 0x0C, 0x07, 0x0B, 0x04, 0x02, 0x08, 0x0D, 0x07, 0x00, 0x09,
	0x03, 0x04, 0x06, 0x0A, 0x02, 0x08, 0x05, 0x0E, 0x0C, 0x0B, 0x0F, 0x01, 0x0D, 0x06, 0x04, 0x09,
	0x08, 0x0F, 0x03, 0x00, 0x0B, 0x01, 0x02, 0x0C, 0x05, 0x0A, 0x0E, 0x07, 0x01, 0x0A, 0x0D, 0x00,
	0x06, 0x09, 0x08, 0x07, 0x04, 0x0F, 0x0E, 0x03, 0x0B, 0x05, 0x02, 0x0C, 0x07, 0x0D, 0x0E, 0x03,
	0x00, 0x06, 0x09, 0x0A, 0x01, 0x02, 0x08, 0x05, 0x0B, 0x0C, 0x04, 0x0F, 0x0D, 0x08, 0x0B, 0x05,
	0x06, 0x0F, 0x00, 0x03, 0x04, 0x07, 0x02, 0x0C, 0x01, 0x0A, 0x0E, 0x09, 0x0A, 0x06, 0x09, 0x00,
	0x0C, 0x0B, 0x07, 0x0D, 0x0F, 0x01, 0x03, 0x0E, 0x05, 0x02, 0x08, 0x04, 0x03, 0x0F, 0x00, 0x06,
	0x0A, 0x01, 0x0D, 0x08, 0x09, 0x04, 0x05, 0x0B, 0x0C, 0x07, 0x02, 0x0E, 0x02, 0x0C, 0x04, 0x01,
	0x07, 0x0A, 0x0B, 0x06, 0x08, 0x05, 0x03, 0x0F, 0x0D, 0x00, 0x0E, 0x09, 0x0E, 0x0B, 0x02, 0x0C,
	0x04, 0x07, 0x0D, 0x01, 0x05, 0x00, 0x0F, 0x0A, 0x03, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01, 0x0B,
	0x0A, 0x0D, 0x07, 0x08, 0x0F, 0x09, 0x0C, 0x05, 0x06, 0x03, 0x00, 0x0E, 0x0B, 0x08, 0x0C, 0x07,
	0x01, 0x0E, 0x02, 0x0D, 0x06, 0x0F, 0x00, 0x09, 0x0A, 0x04, 0x05, 0x03, 0x0C, 0x01, 0x0A, 0x0F,
	0x09, 0x02, 0x06, 0x08, 0x00, 0x0D, 0x03, 0x04, 0x0E, 0x07, 0x05, 0x0B, 0x0A, 0x0F, 0x04, 0x02,
	0x07, 0x0C, 0x09, 0x05, 0x06, 0x01, 0x0D, 0x0E, 0x00, 0x0B, 0x03, 0x08, 0x09, 0x0E, 0x0F, 0x05,
	0x02, 0x08, 0x0C, 0x03, 0x07, 0x00, 0x04, 0x0A, 0x01, 0x0D, 0x0B, 0x06, 0x04, 0x03, 0x02, 0x0C,
	0x09, 0x05, 0x0F, 0x0A, 0x0B, 0x0E, 0x01, 0x07, 0x06, 0x00, 0x08, 0x0D, 0x04, 0x0B, 0x02, 0x0E,
	0x0F, 0x00, 0x08, 0x0D, 0x03, 0x0C, 0x09, 0x07, 0x05, 0x0A, 0x06, 0x01, 0x0D, 0x00, 0x0B, 0x07,
	0x04, 0x09, 0x01, 0x0A, 0x0E, 0x03, 0x05, 0x0C, 0x02, 0x0F, 0x08, 0x06, 0x01, 0x04, 0x0B, 0x0D,
	0x0C, 0x03, 0x07, 0x0E, 0x0A, 0x0F, 0x06, 0x08, 0x00, 0x05, 0x09, 0x02, 0x06, 0x0B, 0x0D, 0x08,
	0x01, 0x04, 0x0A, 0x07, 0x09, 0x05, 0x00, 0x0F, 0x0E, 0x02, 0x03, 0x0C, 0x0D, 0x02, 0x08, 0x04,
	0x06, 0x0F, 0x0B, 0x01, 0x0A, 0x09, 0x03, 0x0E, 0x05, 0x00, 0x0C, 0x07, 0x01, 0x0F, 0x0D, 0x08,
	0x0A, 0x03, 0x07, 0x04, 0x0C, 0x05, 0x06, 0x0B, 0x00, 0x0E, 0x09, 0x02, 0x07, 0x0B, 0x04, 0x01,
	0x09, 0x0C, 0x0E, 0x02, 0x00, 0x06, 0x0A, 0x0D, 0x0F, 0x03, 0x05, 0x08, 0x02, 0x01, 0x0E, 0x07,
	0x04, 0x0A, 0x08, 0x0D, 0x0F, 0x0C, 0x09, 0x00, 0x03, 0x05, 0x06, 0x0B
};
char chArry[] ={
	65, 66, 67, 68,//    A,B,C,D,
	69 ,70 ,71, 72,//    E,F,G,H,
	74 ,75 ,76 ,77,//    J,K,L,M,
	78 ,80 ,81 ,82,//    N,P,Q,R,
	83 ,84 ,85 ,86,//    S,T,U,V,
	87 ,88 ,89 ,90,//    W,X,Y,Z.
	50, 51, 52, 53,//    2,3,4,5,
	54, 55, 56, 57 //    6,7,8,9,
};
char chChangeID[10];
char OldUserID[10] = {};
char A6807F[1450];

void Check(char *pUserID);
char* NewUser(char *pUserID, char* pTwoNum);
int CryptArray(char* a1, char* a2, char* a3);
char* sub_989E7C(char* a1);
signed int sub_989F98(char* a1, int a2);
char* NewLicence(char *pUserID, char *pOtherID, char chZero);
char* SearchDic(char* pDicCode, char chUserCoce);


int main()
{
	unsigned int i = 0, j = 0;
	int x = 5, y = 5;
	j = strlen(chArry);

	srand(time(NULL));
	do 
	{
		do
		{
			do
			{
				unsigned int a = 0, b = 0, c = 0;
				for (int m = 8; m >= 0; m--) {
					int i = rand() % (j - 1);
					OldUserID[m] = chArry[i];

					if (m == 8) {
						a = 32 * i;
					}
					else if (m == 7) {
						b = 32 * (i | a);
					}
					else if (m == 6) {
						c = i | b;
						x = c & 3;
						c >>= 2;
						y = c & 7;//
					}
					if (m <= 5)
					{
						x *= 32;
						x |= i;
					}
				}
			} while (y > 2);
		} while (x < 900000000);
	} while (x > 1500000000);//利用计算机本地计算的返回值就懒得分析写函数了，这边就直接用数值凑数。

 	printf("User ID:%s\n", OldUserID);

	char *pSerialNumber;
	char *pLicenceSecond;
	Check(OldUserID);
	pLicenceSecond = NewLicence(OldUserID, chChangeID, -1);
	pSerialNumber = NewLicence(OldUserID, pLicenceSecond, 0);
	printf("Licence:%s\n", pSerialNumber);
	system("pause");
	return 0;
}

void Check(char *pUserID)
{
	char aTwoNum[3];

	aTwoNum[0] = pUserID[9 - 1];
	aTwoNum[1] = *pUserID;
	aTwoNum[2] = 0;

	NewUser(pUserID, aTwoNum);
	return ;
}

char* NewUser(char *pUserID, char* pTwoNum)
{
	char chSign[66];
	CryptArray(pUserID, pTwoNum, chSign);

	signed int i = 0;
	char *pSign_1 = chSign;
	while (i < 9)
	{
		int nNum = 0;
		signed int j = 0;
		char* pSign_2 = pSign_1;
		do
		{
			nNum = *pSign_2 | 2 * nNum;
			++j;
			++pSign_2;
		} while (j < 5);

		chChangeID[i] = chArry[nNum] + i++;
		*pUserID++;
		pSign_1 += 5;
	}

	pUserID[i] = 0;
	chChangeID[i] = 0;
	return chChangeID;
}

char* NewLicence(char *pUserID, char *pOtherID, char chZero)
{
	wchar_t asc_A0D584[] = { 0x0C, 0x1E, 0x05, 0x13, 0x17, 0x1F, 0x0B, 0x09, 0x1A, 0x11, 0x0A, 0x07 };

	char *pHeapMem = (char*)malloc(sizeof(char) * 48);
	memset(pHeapMem, 0, sizeof(char) * 48);

	signed int j = 0;
	char *pHeapMem_1 = pHeapMem;
	for (char *i = pUserID; j < 12 && *i; ++i)
	{
		*pHeapMem_1 = SearchDic(chArry, *i) - chArry;
		++j;
		pHeapMem_1 += 4;
	}

	int m = 0;
	signed int k = 0;
	char *pHeapMem_2 = pHeapMem;
	wchar_t *pDicAsc = asc_A0D584;
	char *pOtherID_1 = pOtherID;
	while (k < 12 && *pOtherID_1)
	{
		*pHeapMem_2 ^= *pDicAsc;
		char* v9 = SearchDic(chArry, k * chZero + *pOtherID_1);
		if (v9)
			*pHeapMem_2 ^= v9 - chArry;
		++pOtherID_1;
		++pDicAsc;
		pHeapMem_2 += 4;
		++k;
		++m;
	}

	static char chRet[10] = {};
	unsigned __int8 unNum = 1;
	int n = 0;
	for (char *pResult = pHeapMem; n < m; pResult += 4)
	{
		chRet[n] = *(&chArry[*pResult] + 1 - unNum);
		unNum = 1;
		++n;
	}
	free(pHeapMem);
	pHeapMem = NULL;
	return chRet;
}

char* SearchDic(char* pDicCode, char chUserCoce)
{
	char v3;
	char v4;
	char v5;

	char* v2 = pDicCode;
	while (1)
	{
		if (chUserCoce == *v2)
			return v2;
		if (!*v2)
			return 0;
		v3 = *(v2 + 1);
		if (chUserCoce == v3)
			return v2 + 1;
		if (!v3)
			return 0;
		v4 = *(v2 + 2);
		if (chUserCoce == v4)
			return v2 + 2;
		if (!v4)
			return 0;
		v5 = *(v2 + 3);
		if (chUserCoce == v5)
			break;
		v2 += 4;
		if (!v5)
			return 0;
	}
	return v2 + 3;
}

int CryptArray(char* pUser, char* pTwoch, char* pSign)
{
	signed int i = 0;
	char* pSign_1 = pSign;
	do
	{
		*pSign_1 = 0;
		++i;
		++pSign_1;
	} while (i < 66);//置零

	signed int j = 0;
	signed int l;
	while (1)
	{
		l = *pUser;
		if (!*pUser || j >= 64)
			break;

		signed int k = 0;
		char* pSign_2 = &pSign[j];
		char cTemp;
		do
		{
			cTemp = 6 - k++;
			++j;
			*pSign_2++ = (l >> cTemp) & 1;
		} while (k < 7);
		++j;
		++pUser;
	}//一个字母占8个字节,做标记;
	sub_989E7C(pSign);

	signed int m = 0;
	char* pSign_3 = pSign;
	do
	{
		*pSign_3 = 0;
		++m;
		++pSign_3;
	} while (m < 66);

	char* pArray = &A6807F[825];//unk_A683B8
	signed int n = 0;
	do
	{
		//用户名第九位和用户名第一位计算
		signed int nTwoch = *pTwoch++;
		if (nTwoch > 90)
			nTwoch -= 6;
		if (nTwoch > 57)
			nTwoch -= 7;
		signed int v14 = nTwoch - 46;
		signed int p = 0;
		char* pArray_1 = pArray;
		char cArray_2;
		do
		{
			if ((v14 >> p) & 1)
			{
				cArray_2 = *pArray_1;
				*pArray_1 = *(pArray_1 + 24);
				*(pArray_1 + 24) = cArray_2;
			}
			++p;
			pArray_1 = pArray_1 + 1;
		} while (p < 6);
		++n;
		pArray = pArray + 6;
	} while (n < 2);

	signed int q = 0;
	int result;
	do
	{
		result = sub_989F98(pSign, 0);
		++q;
	} while (q < 25);
	return result;
}

char* sub_989E7C(char* a1)
{
	char *v1;
	char *v2;
	char* v3;
	char *v4;
	signed int i;
	char v6;
	signed int v7;
	char* v8;
	signed int v9;
	char v10;
	char* v11;
	signed int v12;
	char *v13;
	char* v14;
	char *v15;
	char* v16;
	char *result;
	char v18;
	char* v19;
	char *v20;
	signed int v21;
	signed int v22;
	signed int v23;


	char DES_pc1[] = {
		0x39, 0x31, 0x29, 0x21, 0x19, 0x11, 0x09, 0x01, 0x3A, 0x32, 0x2A, 0x22, 0x1A, 0x12, 0x0A, 0x02,
		0x3B, 0x33, 0x2B, 0x23, 0x1B, 0x13, 0x0B, 0x03, 0x3C, 0x34, 0x2C, 0x24
	};

	v1 = a_76_5;
	v2 = &A6807F[1];//byte_A68080
	v21 = 0;
	v3 = DES_pc1;
	v4 = &A6807F[29];// &byte_A6809C
	do
	{
		*v2 = *(a1 + *v3 - 1);
		*v4 = *(a1 + *v1 - 1);
		++v21;
		++v4;
		++v1;
		++v2;
		++v3;
	} while (v21 < 28);
	v22 = 0;
	v19 = &A6807F[57];//unk_A680B8
	v20 = &a_76_5[28];
	do
	{
		for (i = 0; i < *v20; ++i)
		{
			v6 = A6807F[1];//byte_A68080
			v7 = 0;
			v8 = &A6807F[2];//unk_A68081
			do
			{
				++v7;
				*(v8 - 1) = *v8;
				++v8;
			} while (v7 < 27);
			A6807F[28] = v6;//byte_A6809B
			v9 = 0;
			v10 = A6807F[29];//byte_A6809C
			v11 = &A6807F[30];//unk_A6809D
			do
			{
				++v9;
				*(v11 - 1) = *v11;
				++v11;
			} while (v9 < 27);
			A6807F[56] = v10;//byte_A680B7
		}
		v12 = 0;
		v13 = &a_76_5[68];
		v14 = v19;
		v15 = &a_76_5[44];
		do
		{
			*v14 = A6807F[0 + *v15];//byte_A6807F[*v15]
			*(v14 + 24) = A6807F[0 + *v13];//byte_A6807F[*v13]
			++v12;
			++v13;
			v14 = v14 + 1;
			++v15;
		} while (v12 < 24);
		++v22;
		v19 = v19 + 48;
		++v20;
	} while (v22 < 16);
	v16 = &A6807F[825];//unk_A683B8
	v23 = 0;
	result = &a_76_5[92];
	do
	{
		v18 = *result++;
		*v16++ = v18;
		++v23;
	} while (v23 < 48);
	return result;
}

signed int sub_989F98(char* a1, int a2)
{
	signed int v2;
	char* v3;
	char* v4;
	int v5;
	signed int v6;
	char* v7;
	char* v8;
	signed int v9;
	char *v10;
	char* v11;
	int v12;
	signed int v13;
	signed int v14;
	int v15;
	signed int v16;
	char *v17;
	char* v18;
	int v19;
	signed int v20;
	char* v21;
	char* v22;
	signed int v23;
	char* v24;
	char v25;
	signed int result;
	char* v27;
	char* v28;
	int v29;
	char *v30;
	char* v31;
	signed int v32;
	int v33;

	char DES_ip[]{
		0x3A, 0x32, 0x2A, 0x22, 0x1A, 0x12, 0x0A, 0x02, 0x3C, 0x34, 0x2C, 0x24, 0x1C, 0x14, 0x0C, 0x04,
		0x3E, 0x36, 0x2E, 0x26, 0x1E, 0x16, 0x0E, 0x06, 0x40, 0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x08,
		0x39, 0x31, 0x29, 0x21, 0x19, 0x11, 0x09, 0x01, 0x3B, 0x33, 0x2B, 0x23, 0x1B, 0x13, 0x0B, 0x03,
		0x3D, 0x35, 0x2D, 0x25, 0x1D, 0x15, 0x0D, 0x05, 0x3F, 0x37, 0x2F, 0x27, 0x1F, 0x17, 0x0F, 0x07
	};
	char DES_p32i[]{
		0x10, 0x07, 0x14, 0x15, 0x1D, 0x0C, 0x1C, 0x11, 0x01, 0x0F, 0x17, 0x1A, 0x05, 0x12, 0x1F, 0x0A,
		0x02, 0x08, 0x18, 0x0E, 0x20, 0x1B, 0x03, 0x09, 0x13, 0x0D, 0x1E, 0x06, 0x16, 0x0B, 0x04, 0x19
	};
	char DES_fp[]{
		0x28, 0x08, 0x30, 0x10, 0x38, 0x18, 0x40, 0x20, 0x27, 0x07, 0x2F, 0x0F, 0x37, 0x17, 0x3F, 0x1F,
		0x26, 0x06, 0x2E, 0x0E, 0x36, 0x16, 0x3E, 0x1E, 0x25, 0x05, 0x2D, 0x0D, 0x35, 0x15, 0x3D, 0x1D,
		0x24, 0x04, 0x2C, 0x0C, 0x34, 0x14, 0x3C, 0x1C, 0x23, 0x03, 0x2B, 0x0B, 0x33, 0x13, 0x3B, 0x1B,
		0x22, 0x02, 0x2A, 0x0A, 0x32, 0x12, 0x3A, 0x1A, 0x21, 0x01, 0x29, 0x09, 0x31, 0x11, 0x39, 0x19
	};

	v2 = 0;
	v3 = &A6807F[873];//unk_A683E8
	v4 = DES_ip;
	do
	{
		v5 = *v4++;
		++v2;
		*v3++ = a1[v5 - 1];
	} while (v2 < 64);
	v32 = 0;
	do
	{
		if (a2)
			v33 = 15 - v32;
		else
			v33 = v32;
		v6 = 0;
		v7 = &A6807F[937];//unk_A68428
		v8 = &A6807F[905];//unk_A68408
		do
		{
			*v7 = *v8;
			++v6;
			++v7;
			++v8;
		} while (v6 < 32);
		v9 = 0;
		v31 = &A6807F[1001];//byte_A68468
		v10 = &A6807F[57] + 48 * v33;//unk_A680B8
		v11 = &A6807F[825];//unk_A683B8
		do
		{
			v12 = *v11++;
			++v9;
			v12 = *v10++ ^ A6807F[904 + v12];//byte_A68407[v12]
			*v31++ = v12;
		} while (v9 < 48);
		v30 = &a_76_5[140];
		v13 = 0;
		do
		{
			v14 = *(&v30[32 * A6807F[1001 + 6 * v13]]		//byte_A68468[6 * v13]
				+ 16 * A6807F[1001 + 6 * v13 + 5]			//byte_A68468[6 * v13 + 5]
				+ 8 * A6807F[1001 + 6 * v13 + 1]			//byte_A68468[6 * v13 + 1]
				+ 4 * A6807F[1001 + 6 * v13 + 2]			//byte_A68468[6 * v13 + 2]
				+ 2 * A6807F[1001 + 6 * v13 + 3]			//byte_A68468[6 * v13 + 3]
				+ A6807F[1001 + 6 * v13 + 4]);				//byte_A68468[6 * v13 + 4]
			v15 = 4 * v13;
			A6807F[969 + v15] = (*(&v30[32 * A6807F[1001 + 6 * v13]]	//byte_A68468[6 * v13]		byte_A68448[v15]
				+ 16 * A6807F[1001 + 6 * v13 + 5]						//byte_A68468[6 * v13 + 5]
				+ 8 * A6807F[1001 + 6 * v13 + 1]						//byte_A68468[6 * v13 + 1]
				+ 4 * A6807F[1001 + 6 * v13 + 2]						//byte_A68468[6 * v13 + 2]
				+ 2 * A6807F[1001 + 6 * v13 + 3]						//byte_A68468[6 * v13 + 3]
				+ A6807F[1001 + 6 * v13 + 4]) >> 3) & 1;				//byte_A68468[6 * v13 + 4]
			A6807F[970 + v15] = (v14 >> 2) & 1;							//byte_A68449[v15]
			A6807F[971 + v15] = (v14 >> 1) & 1;							//byte_A6844A[v15]
			A6807F[972 + v15] = v14 & 1;								//byte_A6844B[v15]
			++v13;
			v30 += 64;
		} while (v13 < 8);
		v16 = 0;
		v17 = DES_p32i;
		v18 = &A6807F[873];//unk_A683E8
		do
		{
			v19 = *v17++;
			++v16;
			*(v18 + 32) = A6807F[968 + v19] ^ *v18;//byte_A68447[v19]
			v18 = v18 + 1;
		} while (v16 < 32);
		v20 = 0;
		v21 = &A6807F[873];//unk_A683E8
		v22 = &A6807F[937];//unk_A68428
		do
		{
			*v21 = *v22;
			++v20;
			++v21;
			++v22;
		} while (v20 < 32);
		++v32;
	} while (v32 < 16);
	v23 = 0;
	v24 = &A6807F[873];//unk_A683E8
	do
	{
		v25 = *v24;
		*v24 = *(v24 + 32);
		*(v24 + 32) = v25;
		++v23;
		v24 = v24 + 1;
	} while (v23 < 32);
	result = 0;
	v27 = a1;
	v28 = DES_fp;
	do
	{
		v29 = *v28++;
		++result;
		*v27++ = A6807F[872 + v29];//byte_A683E7[v29]
	} while (result < 64);
	return result;
}

